{"/home/travis/build/npmtest/node-npmtest-scraperjs/test.js":"/* istanbul instrument in package npmtest_scraperjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-scraperjs/lib.npmtest_scraperjs.js":"/* istanbul instrument in package npmtest_scraperjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_scraperjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_scraperjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-scraperjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-scraperjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_scraperjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_scraperjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_scraperjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_scraperjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_scraperjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_scraperjs.__dirname + '/lib.npmtest_scraperjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/Scraper.js":"var StaticScraper = require('./StaticScraper.js'),\n\tDynamicScraper = require('./DynamicScraper.js'),\n\tScraperPromise = require('./ScraperPromise.js'),\n\tRouter = require('./Router');\n\nmodule.exports = {\n\tStaticScraper: StaticScraper,\n\tDynamicScraper: DynamicScraper,\n\tScraperPromise: ScraperPromise,\n\tRouter: Router\n};","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/StaticScraper.js":"var cheerio = require('cheerio'),\n\tAbstractScraper = require('./AbstractScraper');\n\n/**\n * A static scraper. This can only scrape static content, with the\n *   help of jQuery.\n * This version uses cheerio {@link https://github.com/cheeriojs/cheerio}.\n *\n * @extends {AbstractScraper}\n */\nvar StaticScraper = function() {\n\tAbstractScraper.call(this);\n\t/**\n\t * jQuery.\n\t *\n\t * @type {!function}\n\t * @private\n\t */\n\tthis.$ = null;\n};\nStaticScraper.prototype = Object.create(AbstractScraper.prototype);\n/**\n * @override\n * @inheritDoc\n */\nStaticScraper.prototype.loadBody = function(done) {\n\tthis.$ = cheerio.load(this.body);\n\tdone();\n\treturn this;\n};\n/**\n * Scrapes the webpage. According to a function, and a callback.\n *\n * @param  {!function(function(), ...?)} scraperFn Function to scrape\n *   the content. It receives the jQuery function to manipulate the\n *   DOM, and the args as parameters, if passed.\n * @param  {!function(?)} callbackFn Function that receives the\n *   result of the scraping.\n * @param  {!Array=} args Extra arguments to pass to the scraping\n *   function.\n * @return {!AbstractScraper} This scraper.\n * @override\n * @public\n */\nStaticScraper.prototype.scrape = function(scraperFn, callbackFn, args) {\n\tvar result = null, err = null;\n\targs = args || [];\n\targs.unshift(this.$);\n\ttry {\n\t\tresult = scraperFn.apply(null, args);\n\t} catch (e) {\n\t\terr = e;\n\t}\n\tcallbackFn(err, result);\n\treturn this;\n};\n/**\n * @override\n * @inheritDoc\n */\nStaticScraper.prototype.close = function() {\n\treturn this;\n};\n/**\n * @override\n * @inheritDoc\n */\nStaticScraper.prototype.clone = function() {\n\treturn new StaticScraper();\n};\n/**\n * Creates a static scraper, wrapped around a scraper promise.\n *\n * @param  {!string=} url If provided makes an HTTP GET request to the\n *   given URL.\n * @return {!ScraperPromise} Scraper promise, with a static scraper.\n * @public\n * @static\n */\nStaticScraper.create = function(url) {\n\treturn AbstractScraper.create(StaticScraper, url);\n};\n\nmodule.exports = StaticScraper;","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/AbstractScraper.js":"var request = require('request'),\n\tScraperPromise = require('./ScraperPromise');\n\n/**\n * An abstract scraper, this class should not be used directly as a\n *   scraper, instead a concrete scraper should inherit or use this\n *   class as a composite this class.\n *\n * @constructor\n */\nvar AbstractScraper = function() {\n\t/**\n\t * Status code of the last requested page.\n\t *\n\t * @type {!number}\n\t * @protected\n\t */\n\tthis.statusCode = null;\n\t/**\n\t * Response of the last requested page.\n\t *\n\t * @type {!Object}\n\t * @protected\n\t */\n\tthis.response = null;\n\t/**\n\t * Body of the last webpage, as a string.\n\t *\n\t * @type {!string}\n\t * @protected\n\t */\n\tthis.body = null;\n\t/**\n\t * URL.\n\t *\n\t * @type {!string}\n\t * @protected\n\t */\n\tthis.url = '';\n};\nAbstractScraper.prototype = {\n\tconstructor: AbstractScraper,\n\t/**\n\t * Executes a simple HTTP GET request to the given url.\n\t *\n\t * @param  {!string} url URL to request.\n\t * @param  {!function(Error=)} callback Function to call when the\n\t *   request is done. If the request was successful then it's\n\t *   called with no arguments or null argument. Otherwise, if\n\t *   there was an error the it's called with one argument not\n\t *   null, that should be an error instance.\n\t * @return {!AbstractScraper} This scraper.\n\t * @public\n\t */\n\tget: function(url, callback) {\n\t\tvar that = this;\n\t\trequest.get(url, function processGet(error, response, body) {\n\t\t\tif (error) {\n\t\t\t\tcallback(error);\n\t\t\t} else {\n\t\t\t\tthat.response = response;\n\t\t\t\tthat.statusCode = response.statusCode;\n\t\t\t\tthat.body = body;\n\t\t\t\tthat.url = response.request.href;\n\t\t\t\tthat.loadBody(function(err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Executes an HTTP request to an url. This method allows for the\n\t *   powerful use of the request package {@link https://github.com/mikeal/request},\n\t *   since it's basically a wrapper around the method request.\n\t *   For more information about how it's used refer to {@link https://github.com/mikeal/request#requestoptions-callback}.\n\t *\n\t * @param  {!(Object|string)} options Options of the request.\n\t * @param  {!function(Error=)} callback Function to call when the\n\t *   request is done. If the request was successful then it's\n\t *   called with no arguments or null argument. Otherwise, if\n\t *   there was an error the it's called with one argument not\n\t *   null, that should be an error instance.\n\t * @return {!AbstractScraper} This scraper.\n\t * @public\n\t */\n\trequest: function(options, callback) {\n\t\tvar that = this;\n\t\trequest(options, function processRequest(error, response, body) {\n\t\t\tif (error) {\n\t\t\t\tcallback(error);\n\t\t\t} else {\n\t\t\t\tthat.response = response;\n\t\t\t\tthat.statusCode = response.statusCode;\n\t\t\t\tthat.body = body;\n\t\t\t\tthat.url = response.request.href;\n\t\t\t\tthat.loadBody(function(err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Gets the status code of the last request.\n\t *\n\t * @return {?number} The status code, if a there was a successful\n\t *   request, null otherwise.\n\t * @public\n\t */\n\tgetStatusCode: function() {\n\t\treturn this.statusCode;\n\t},\n\t/**\n\t * Gets the response of the last request.\n\t *\n\t * @return {?number} The status code, if a there was a successful\n\t *   request, null otherwise.\n\t * @public\n\t */\n\tgetResponse: function() {\n\t\treturn this.response;\n\t},\n\t/**\n\t * Gets the body of the last request.\n\t *\n\t * @return {?number} The status code, if a there was a successful\n\t *   request, null otherwise.\n\t * @public\n\t */\n\tgetBody: function() {\n\t\treturn this.body;\n\t},\n\t/* jshint unused:false */\n\t/**\n\t * Loads the string, to a representation that can be used in the\n\t *   scraping process.\n\t *\n\t * @param  {!function()} done Callback function, for when the body\n\t *   is done loading.\n\t * @return {!AbstractScraper} This scraper.\n\t * @protected\n\t */\n\tloadBody: function(done) {\n\t\tdone();\n\t\treturn this;\n\t},\n\t/**\n\t * Scrapes the webpage. According to a function, and a callback.\n\t *\n\t * @param  {!function(...?)} scraperFn Function to scrape the\n\t *   content.\n\t * @param  {!function(?)} callbackFn Function that receives the\n\t *   result of the scraping.\n\t * @param  {!Array} args Aditional arguments to pass to the\n\t *   scraping function.\n\t * @return {!AbstractScraper} This scraper.\n\t * @public\n\t */\n\tscrape: function(scraperFn, callbackFn, args) {},\n\t/**\n\t * Closes the scraper.\n\t *\n\t * @return {!AbstractScraper} This scraper.\n\t * @public\n\t */\n\tclose: function() {},\n\t/**\n\t * Clones the scraper.\n\t *\n\t * @return {!AbstractScraper} Empty clone.\n\t * @public\n\t */\n\tclone: function() {}\n};\n/* jshint unused:true */\n\n/**\n * Creates a scraper, based on a scraper type, and creates it's\n *   promise.\n *\n * @param  {!AbstractScraper} ScraperType Some concrete implementation\n *   of an abstract scraper.\n * @param  {!string=} url Url to make an HTTP GET request.\n * @return {!ScraperPromise} A scraper promise.\n * @public\n * @static\n */\nAbstractScraper.create = function(ScraperType, url, options) {\n\tvar promise = new ScraperPromise(new ScraperType(options));\n\tif (url) {\n\t\tpromise.get(url);\n\t}\n\treturn promise;\n};\n\nmodule.exports = AbstractScraper;","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/ScraperPromise.js":"var async = require('async');\n\n/**\n * @constructor\n */\nvar ScraperPromise = function(scraper) {\n\t/**\n\t * Scraper to use..\n\t *\n\t * @type {!Scraper}\n\t * @private\n\t */\n\tthis.scraper = scraper;\n\t/**\n\t * Promise chunks.\n\t *\n\t * @type {!Array.<function(function(?))>}\n\t * @private\n\t */\n\tthis.promises = [];\n\t/**\n\t * Function to call when all the promises are fulfilled.\n\t *\n\t * @type {!function(?, ?)}\n\t * @private\n\t */\n\tthis.doneCallback = function(last, utils) {\n\t\treturn last;\n\t};\n\t/**\n\t * Function to call when there's an error.\n\t *\n\t * @type {!function(?)}\n\t * @private\n\t */\n\tthis.errorCallback = function(err) {\n\t\tthrow err;\n\t};\n\t/**\n\t * A parameter object to be passed to the chain, at the _fire\n\t *   method. This should be set immediately before the call, and\n\t *   reset to null right after the call, or after it's been stored\n\t *   elsewhere.\n\t *\n\t * @type {?}\n\t * @private\n\t */\n\tthis.chainParameter = null;\n};\nScraperPromise.prototype = {\n\tconstructor: ScraperPromise,\n\t/**\n\t * Sets a promise for a status code, of a response of a request.\n\t *\n\t * @param  {!(number|function(number))} code Status code to\n\t *   dispatch the message. Or a callback function, in this case\n\t *   the function's first parameter is the status code, as a\n\t *   number.\n\t * @param  {!function()} callback Callback function for the case\n\t *   where the status code is provided.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\tonStatusCode: function(code, callback) {\n\t\tif (typeof code == 'function') {\n\t\t\tcallback = code;\n\t\t\tthis.promises.push(function onGenericStatusCode(done, utils) {\n\t\t\t\tdone(null, callback(this.scraper.getStatusCode(), utils));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.promises.push(function onStatusCode(done, utils) {\n\t\t\t\tif (code === this.scraper.getStatusCode()) {\n\t\t\t\t\tdone(null, callback(utils));\n\t\t\t\t} else {\n\t\t\t\t\tdone(null, utils.lastReturn);\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * Sets a promise to scrape the retrieved webpage.\n\t *\n\t * @param  {!function(?, ?)} scrapeFn Function to scrape the\n\t *   webpage. The parameters depend on what kind of scraper.\n\t * @param  {!function(?)=} callback Callback function with the\n\t *   result of the scraping function. If none is provided, the\n\t *   result can be accessed in the next promise with\n\t *   <code>utils.lastReturn</code>.\n\t * @param  {...?} var_args Optional arguments to pass as\n\t *   parameters to the scraping function.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\tscrape: function(scrapeFn, callback) {\n\t\tvar stackTrace = new Error().stack;\n\n\t\tvar extraArguments = Array.prototype.slice.call(arguments, 2);\n\t\tcallback = callback || function(result) {\n\t\t\treturn result;\n\t\t};\n\t\tthis.promises.push(function scrape(done, utils) {\n\t\t\tthis.scraper.scrape(scrapeFn, function(err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\tdone(err, undefined);\n\t\t\t\t} else {\n\t\t\t\t\tdone(null, callback(result, utils));\n\t\t\t\t}\n\t\t\t}, extraArguments, stackTrace);\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Sets a promise to delay the execution of the promises.\n\t *\n\t * @param  {!number} time Time in milliseconds to delay the\n\t *   execution.\n\t * @param  {!function()=} callback Function to call after the\n\t *   delay.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\tdelay: function(time, callback) {\n\t\tcallback = callback || function() {};\n\t\tthis.promises.push(function delay(done, utils) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tdone(null, callback(utils));\n\t\t\t}, time);\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Sets a promise to execute a promise after a time period. This\n\t *   does not cause the promise chain to block.\n\t *\n\t * @param  {!number} time Time in milliseconds to the execution of\n\t *   the callback.\n\t * @param  {!function()} callback Function to call after the\n\t *   time period has passed.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\ttimeout: function(time, callback) {\n\t\tthis.promises.push(function timeout(done, utils) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tcallback(utils);\n\t\t\t}, time);\n\t\t\tdone(null, null);\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Sets the end of the promise chain callback, if there were no\n\t *   errors.\n\t *\n\t * @param  {!function()} doneFn Callback function.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\tdone: function(doneFn) {\n\t\tthis.doneCallback = doneFn;\n\t\treturn this;\n\t},\n\t/**\n\t * Sets a generic promise.\n\t *\n\t * @param  {!function()} callback Callback.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\tthen: function(callback) {\n\t\tthis.promises.push(function then(done, utils) {\n\t\t\tdone(null, callback(utils.lastReturn, utils));\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Stops the promise chain and resumes it after a callback\n\t *   function.\n\t *\n\t * @param  {!function(!function, !Object)} callback Callback.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\tasync: function(callback) {\n\t\tthis.promises.push(function async(done, utils) {\n\t\t\tcallback(utils.lastReturn, done, utils);\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * @deprecated\n\t */\n\tonError: function(callback) {\n\t\tconsole.warn(\"The 'onError' is being DEPRECATED in favor of 'catch'\");\n\t\treturn this.catch(callback);\n\t},\n\t/**\n\t * Sets a promise to when an error occur, note that an error will\n\t *   break the promise chain, so this is the next promise to be\n\t *   called and if the done promise is not set the last. To avoid\n\t *   silent errors, if this promise is not defined the error will\n\t *   be thrown up.\n\t *\n\t * @param  {!function(?)} callback Callback.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\t\"catch\": function(callback) {\n\t\tthis.errorCallback = callback;\n\t\treturn this;\n\t},\n\t/**\n\t * Makes an HTTP GET request to the url.\n\t *\n\t * @param  {!string} url Url to make the request.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\tget: function(url) {\n\t\tvar that = this;\n\t\tthis.scraper.get(url, function(err) {\n\t\t\tthat._fire(err);\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Makes a (possible more complex) HTTP request. For more\n\t *   information refer to {@link https://github.com/mikeal/request#requestoptions-callback}.\n\t *\n\t * @param  {!Object} options Options of the request.\n\t * @return {!ScraperPromise} This object, so that new promises can\n\t *   be made.\n\t * @public\n\t */\n\trequest: function(options) {\n\t\tvar that = this;\n\t\tthis.scraper.request(options, function(err) {\n\t\t\tthat._fire(err);\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Sets a parameter to be used in the next _fire call.\n\t *\n\t * @param {?Object} param Parameter.\n\t * @public\n\t */\n\t_setChainParameter: function(param) {\n\t\tthis.chainParameter = param;\n\t},\n\t/**\n\t * Starts the promise chain.\n\t *\n\t * @param  {?} error Error object, to fire the error callback,\n\t *   from an error that happened before.\n\t * @param  {!Scraper} scraper Scraper to use in the promise chain.\n\t * @protected\n\t */\n\t_fire: function(error) {\n\t\tvar that = this,\n\t\t\tparam = this.chainParameter,\n\t\t\tstopPointer = {},\n\t\t\tutils = {\n\t\t\t\tstop: null,\n\t\t\t\turl: this.scraper.url,\n\t\t\t\tscraper: this,\n\t\t\t\tparams: param,\n\t\t\t\tlastReturn: undefined\n\t\t\t},\n\t\t\tkeep = true;\n\t\tthis.chainParameter = null;\n\n\t\tif (error) {\n\t\t\tthis.errorCallback(error, utils);\n\t\t\tthis.doneCallback(utils);\n\t\t\treturn;\n\t\t}\n\n\t\tasync.eachSeries(this.promises, function dispatcher(fn, callback) {\n\t\t\tvar done = function(err, lastReturn) {\n\t\t\t\tutils.lastReturn = lastReturn;\n\t\t\t\tif (err === stopPointer) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else if (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else if (keep) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t};\n\t\t\tutils.stop = function() {\n\t\t\t\tdone(stopPointer, null);\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tfn.call(that, done, utils);\n\t\t\t} catch (err) {\n\t\t\t\tdone(err, null);\n\t\t\t}\n\t\t}, function(err) {\n\t\t\tutils.stop = null;\n\t\t\tif (err && err !== stopPointer) {\n\t\t\t\tthat.errorCallback(err, utils);\n\t\t\t}\n\t\t\tthat.doneCallback(utils.lastReturn, utils);\n\t\t\tthat.scraper.close();\n\t\t});\n\t},\n\t/**\n\t * Sets the promises.\n\t *\n\t * @param {!Array.<function(function(?))>} promises Promises array.\n\t * @public\n\t */\n\t_setPromises: function(promises) {\n\t\tthis.promises = promises;\n\t},\n\t/**\n\t * Clones the promise and the scraper.\n\t *\n\t * @return {!ScraperPromise} Scraper promise with an empty scraper\n\t *   clone.\n\t * @public\n\t */\n\tclone: function() {\n\t\tvar instance = this.scraper.clone(),\n\t\t\tpromise = new ScraperPromise(instance);\n\t\tpromise._setPromises(this.promises);\n\t\tpromise.done(this.doneCallback);\n\t\tpromise.catch(this.errorCallback);\n\t\treturn promise;\n\t}\n};\n\nmodule.exports = ScraperPromise;\n","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/DynamicScraper.js":"var phantomOrig = require('phantom'),\n\tPhantomPoll = require('./PhantomPoll.js'),\n\tphantom = phantomOrig,\n\tAbstractScraper = require('./AbstractScraper'),\n\tScraperError = require('./ScraperError'),\n\tPhantomWrapper = require('./PhantomWrapper');\n\n/**\n * A dynamic scraper. This is a very versatile and powerful. This\n *   solution is a little heavier and slower than the {@see StaticScraper}.\n * This version uses phantomjs {@link http://phantomjs.org/}, and {@link https://github.com/sgentle/phantomjs-node}.\n *\n * @extends {AbstractScraper}\n */\nvar DynamicScraper = function(options) {\n\tAbstractScraper.call(this);\n\t/**\n\t * Phantom instance.\n\t *\n\t * @type {?}\n\t * @private\n\t */\n\tthis.ph = null;\n\t/**\n\t * Phantom's page.\n\t *\n\t * @type {?}\n\t * @private\n\t */\n\tthis.page = null;\n\t/**\n\t * Phantom's options\n\t *\n\t * @type {?}\n\t * @private\n\t */\n\tthis.options = {\n\t\tonStdout: function() {},\n\t\tonStderr: function() {}\n\t};\n\tfor (var key in options) { this.options[key] = options[key]; }\n};\nDynamicScraper.prototype = Object.create(AbstractScraper.prototype);\n/**\n * @override\n * @inheritDoc\n */\nDynamicScraper.prototype.loadBody = function(done) {\n\tvar that = this;\n\tphantom.create('--load-images=no', that.options, function(ph) {\n\t\tthat.ph = ph;\n\t\tph.createPage(function(page) {\n\t\t\tthat.page = page;\n\t\t\tpage.setContent(that.body, that.url, function() {\n\t\t\t\tthat.inject(DynamicScraper.JQUERY_FILE, function(err) {\n\t\t\t\t\tdone(err ? new ScraperError('Couldn\\'t inject jQuery into the page.') : undefined);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\treturn this;\n};\n/**\n * The scraper function has it's own scope (can't access outside its\n *   own scope), and only JSON serializable information can be return\n *   by the function. For more information {@link https://github.com/sgentle/phantomjs-node}.\n *\n * @param  {!function(...?)} scraperFn Function to scrape the content.\n *   It receives the args as parameters, if passed.\n * @param  {!function(?)} callbackFn Function that receives the\n *   result of the scraping.\n * @param  {!Array=} args Additional arguments to pass to the scraping\n *   function. They must be JSON serializable.\n * @param  {!string=} stackTrace Stack trace to produce better error\n *   messages.\n * @return {!AbstractScraper} This scraper.\n * @override\n * @public\n */\nDynamicScraper.prototype.scrape = function(scraperFn, callbackFn, args, stackTrace) {\n\targs = args || [];\n\n\targs.unshift(scraperFn.toString());\n\targs.unshift(function(result) {\n\t\tif(result.error) {\n\t\t\tcallbackFn(DynamicScraper.generateMockErrorMessage(result.error, stackTrace), null);\n\t\t} else {\n\t\t\tcallbackFn(null, result.result);\n\t\t}\n\t});\n\targs.unshift(PhantomWrapper);\n\n\tthis.page.evaluate.apply(this.page, args);\n\treturn this;\n};\n/**\n * Injects a javascript file into the page.\n *\n * @param  {!string} file File to inject.\n * @param  {!function(!ScraperError=)} callback Function to be called\n *   when the file has injected. If the injection fails, then the\n *   first argument is not is a {@see ScraperError}.\n * @public\n */\nDynamicScraper.prototype.inject = function(file, callback) {\n\tif (this.page) {\n\t\tthis.page.injectJs(file, function(success) {\n\t\t\tif (success) {\n\t\t\t\tcallback();\n\t\t\t} else {\n\t\t\t\tcallback(new ScraperError('Couldn\\'t inject code, at \"' + file + '\".'));\n\t\t\t}\n\t\t});\n\t} else {\n\t\tthrow new ScraperError('Couldn\\'t inject code, at \"' + file + '\". The page has not been initialized yet.');\n\t}\n};\n/**\n * @override\n * @inheritDoc\n */\nDynamicScraper.prototype.close = function() {\n\tif (this.page) {\n\t\tthis.page.close();\n\t}\n\tif (this.ph) {\n\t\tthis.ph.exit();\n\t}\n\treturn this;\n};\n/**\n * @override\n * @inheritDoc\n */\nDynamicScraper.prototype.clone = function() {\n\treturn new DynamicScraper();\n};\n/**\n * Creates a dynamic scraper, wrapped around a scraper promise.\n *\n * @param  {!string=} url If provided makes an HTTP GET request to the\n *   given URL.\n * @return {!ScraperPromise} Scraper promise, with a dynamic scraper.\n * @public\n * @static\n */\nDynamicScraper.create = function(url, options) {\n\treturn AbstractScraper.create(DynamicScraper, url, options);\n};\n/**\n * Starts the factory. A factory should only be open once, and after\n *   it's open it must be closed with {@see DynamicScraper#closeFactory}.\n *   A factory makes so that there's only one instance of phantom at a\n *   time, which makes the creation/usage of dynamic scrapers much\n *   more efficient.\n *\n * @return {!DynamicScraper}\n * @public\n * @static\n */\nDynamicScraper.startFactory = function() {\n\tphantom = new PhantomPoll();\n\treturn DynamicScraper;\n};\n/**\n * Closes the factory. For more information {@see DynamicScraper#closeFactory}\n *\n * @return {!DynamicScraper}\n * @public\n * @static\n */\nDynamicScraper.closeFactory = function() {\n\tif (phantom instanceof PhantomPoll) {\n\t\tphantom.close();\n\t}\n\tphantom = phantomOrig;\n\treturn DynamicScraper;\n};\n/**\n * Generates a mock error message that is similar to one produced\n *   by a function runned in node, and not phantomjs.\n * @param  {!Object} err       \tError object sent by Phantom.\n * @param  {!string} stackTrace Stack trace of where the promise was defined.\n * @return {!Error}             Error message.\n * @private\n * @static\n */\nDynamicScraper.generateMockErrorMessage = function(err, stackTrace) {\n\tvar rg = /^\\s{4}at ([^\\s]+) \\(([^\\s]*)\\:(\\d+):(\\d+)\\)$/mg;\n\trg.exec(stackTrace);\n\tvar emsg = rg.exec(stackTrace);\n\tvar sob = emsg[1];\n\tvar sfile = emsg[2];\n\tvar sline = emsg[3];\n\tvar sc = emsg[4];\n\n\tvar line = Number(sline) + Math.max(err.line-1, 0);\n\n\tvar mock = new Error(err.message);\n\t// Prevents the use of a property named 'line'!\n\tdelete err.line;\n\tfor(var x in err) {\n\t\tmock[x] = err[x];\n\t}\n\tmock.stack = mock.stack.replace(/\\t/g, '    ');\n\n\tvar ats = mock.stack.split('\\n');\n\tats.unshift('    at ' + sob + ' (' + sfile + ':' + line + ':' + sc + ')');\n\tats.unshift('Error' + (err.message?': '+err.message:''));\n\tmock.stack = ats.join('\\n');\n\n\treturn mock;\n};\n/**\n * Location of the jquery file.\n *\n * @type {!string}\n * @private\n * @static\n */\nDynamicScraper.JQUERY_FILE = require.resolve('jquery');\n\nmodule.exports = DynamicScraper;\n","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/PhantomPoll.js":"var phantom = require('phantom');\n\n/**\n * This maintains only one PhantomJS instance. It works like a proxy\n *   between the phantom package, and should expose the methods same\n *   methods. An additional call to close the phantomJS instance\n *   properly is needed.\n *\n * @constructor\n */\nvar PhantomPoll = function() {\n\t/**\n\t * The real PhantomJS instance.\n\t *\n\t * @type {?}\n\t * @private\n\t */\n\tthis.instance = null;\n\t/**\n\t * The PhantomJS instance is being created.\n\t *\n\t * @type {!boolean}\n\t * @private\n\t */\n\tthis.creating = false;\n\t/**\n\t * PhantomJS flags.\n\t *\n\t * @type {!string}\n\t * @private\n\t */\n\tthis.flags = '';\n\t/**\n\t * PhantomJS options.\n\t *\n\t * @type {!Object}\n\t * @private\n\t */\n\tthis.options = {\n\t\tonStdout: function() {},\n\t\tonStderr: function() {}\n\t};\n\t/**\n\t * List of functions waiting to be called after the PhantomJS\n\t *   instance is created.\n\t *\n\t * @type {!Array.<!function(?)>}\n\t * @private\n\t */\n\tthis.waiting = [];\n\tthis._createInstance();\n};\nPhantomPoll.prototype = {\n\tconstructor: PhantomPoll,\n\t/**\n\t * Creates a PhantomJS page, to be called with a callback, which\n\t *   will receive the page.\n\t *\n\t * @param  {!function(?)} callback Function to be called after the\n\t *   page is created, it receives the page object.\n\t * @public\n\t */\n\tcreatePage: function(callback) {\n\t\tif (this.instance) {\n\t\t\tthis.instance.createPage(function(page) {\n\t\t\t\tcallback(page);\n\t\t\t});\n\t\t} else {\n\t\t\tvar that = this;\n\t\t\tthis._createInstance(function() {\n\t\t\t\tthat.createPage(callback);\n\t\t\t});\n\t\t}\n\t},\n\t/**\n\t * Creates a PhantomJS instance.\n\t *\n\t * @param  {!string} flags Creation flags.\n\t * @param  {!Object} options Creation options.\n\t * @param  {!function(?)} callback Function to be called after\n\t *   the phantom instance is created.\n\t *\n\t * @public\n\t */\n\tcreate: function(flags, options, callback) {\n\t\tthis.flags = flags;\n\t\tthis.options = options;\n\t\tcallback(this);\n\t},\n\t/**\n\t * Creates PhantomJS instance if needed be, and when it's done\n\t *   triggers all the callbacks.\n\t *\n\t * @param  {!function(?)} callback Function to be called when the\n\t *   instance is created, if a phantom instance is waiting to be\n\t *   created the callback will be added to a waiting list.\n\t * @private\n\t */\n\t_createInstance: function(callback) {\n\t\tif (this.creating && callback) {\n\t\t\tthis.waiting.push(callback);\n\t\t} else {\n\t\t\tvar that = this;\n\t\t\tthis.creating = true;\n\t\t\tphantom.create(this.flags, this.options, function(ph) {\n\t\t\t\tthat.instance = ph;\n\t\t\t\tthat.creating = false;\n\t\t\t\tthat.waiting.forEach(function(callback) {\n\t\t\t\t\tcallback(ph);\n\t\t\t\t});\n\t\t\t\tthat.waiting = [];\n\t\t\t});\n\t\t}\n\t},\n\t/**\n\t * This is a function just to maintain the same interface\n\t *   with the phantom module. If the PhantomJS instance needs be\n\t *   destroyed the method close must be used.\n\t *\n\t * @public\n\t */\n\texit: function() {},\n\t/**\n\t * Exits the phantom instance.\n\t *\n\t * @public\n\t */\n\tclose: function() {\n\t\tif (this.instance) {\n\t\t\tthis.instance.exit();\n\t\t}\n\t}\n};\n\nmodule.exports = PhantomPoll;","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/ScraperError.js":"/**\n * A scraper error, to refer error occurred in the scope of this\n *   package. For more information about the error use it's message\n *   property.\n *\n * @param   {!string} message Error message.\n * @extends {Error}\n */\nvar ScraperError = function(message) {\n\t/**\n\t * Error message.\n\t *\n\t * @type {!string}\n\t * @public\n\t */\n\tthis.message = message;\n\t/**\n\t * This type.\n\t *\n\t * @type {!string}\n\t * @public\n\t */\n\tthis.name = 'ScraperError';\n\t/**\n\t * Stack message.\n\t *\n\t * @type {!string}\n\t * @public\n\t */\n\tthis.stack = (new Error()).stack;\n};\nScraperError.prototype = new Error();\nScraperError.prototype.constructor = ScraperError;\n\nmodule.exports = ScraperError;","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/PhantomWrapper.js":"module.exports = function wrapper(fnStr) {\n  var args = Array.prototype.slice.call(arguments);\n  var rg = /^function\\s+([a-zA-Z_$][a-zA-Z_$0-9]*)?\\((.*?)\\) {/g;\n  var a = rg.exec(fnStr);\n  var fnArgs = a[2].match(/([^,\\s]+)/g) || [];\n  var fnBody = fnStr.slice(fnStr.indexOf(\"{\")+1, fnStr.lastIndexOf(\"}\"));\n  fnArgs.push(fnBody);\n  var scraperFn = Function.apply(this, fnArgs);\n\n  try {\n    var gs = args.slice(1);\n    gs.unshift($);\n    var result = scraperFn.apply(this, gs);\n    return {\n      error: null,\n      result: result\n    };\n  } catch(e) {\n    var errObj = {\n      message: e.message\n    };\n    for(var x in e) {\n      errObj[x] = e[x];\n    }\n    return {\n      error: errObj,\n      result: null\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/Router.js":"var async = require('async'),\n\tStaticScraper = require('./StaticScraper'),\n\tDynamicScraper = require('./DynamicScraper'),\n\tScraperError = require('./ScraperError');\n\n/**\n * Transforms a string into a regular expression.\n * This function is from the project Routes.js, under the MIT licence,\n *   {@link https://github.com/aaronblohowiak/routes.js} it's present\n *   in the file {@link https://github.com/aaronblohowiak/routes.js/blob/bdad0a1ae10d11981bb286550bb3b8a1a71909bd/dist/routes.js#L49}.\n *\n * @param  {!string} path String path.\n * @param  {!Array.<string>} keys Empty array to be filled with the\n *   keys ids.\n * @return {!RegExp} Regular expression.\n */\nfunction pathToRegExp(path, keys) {\n\tpath = path\n\t\t.concat('/?')\n\t\t.replace(/\\/\\(/g, '(?:/')\n\t\t.replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?|\\*/g, function(_, slash, format, key, capture, optional) {\n\t\t\tif (_ === '*') {\n\t\t\t\treturn _;\n\t\t\t}\n\n\t\t\tkeys.push(key);\n\t\t\tslash = slash || '';\n\t\t\treturn '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (format || '') + (capture || '([^/]+?)') + ')' + (optional || '');\n\t\t})\n\t\t.replace(/([\\/.])/g, '\\\\$1')\n\t\t.replace(/\\*/g, '(.*)');\n\treturn new RegExp('^' + path + '$', 'i');\n}\n\n/**\n * Routes an url thought a valid, predefined, path.\n *\n * @param {!Object=} options Setup options.\n * @param {!boolean=} options.firstMatch If true the router will stop\n *   at the first path matched. The default is false, and tries to\n *   match every path.\n * @constructor\n */\nvar Router = function(options) {\n\toptions = options || {};\n\t/**\n\t * Stops routing at first successful match.\n\t *\n\t * @type {!boolean}\n\t * @private\n\t */\n\tthis.firstMatchStop = options.firstMatch || false;\n\t/**\n\t * Chain of promises.\n\t *\n\t * @type {!Array.<!Object>}\n\t * @private\n\t */\n\tthis.promises = [];\n\t/**\n\t * Otherwise promise.\n\t *\n\t * @type {!function(!string=)}\n\t * @private\n\t */\n\tthis.otherwiseFn = function() {};\n};\nRouter.prototype = {\n\tconstructor: Router,\n\t/**\n\t * Promise to url match. It's promise will fire only if the path\n\t *   matches with and url being routed.\n\t *\n\t * @param  {!(string|RegExp|function(string):?)} path The\n\t *   path or regular expression to match an url.\n\t *   Alternatively a function that receives the url to be matched\n\t *   can be passed. If the result is false, or any\n\t *   !!result===false), the path is considered valid and the\n\t *   scraping should be done. If ,in case of a valid path, an Object is returned, it will be associated with the params of this\n\t *   route/path.\n\t *   For more information on the path matching refer to {@link https://github.com/aaronblohowiak/routes.js/blob/76bc517037a0321507c4d84a0cdaca6db31ebaa4/README.md#path-formats}\n\t * @return {!Router} This router.\n\t * @public\n\t */\n\ton: function(path) {\n\t\tvar callback;\n\t\tif (typeof path === 'function') {\n\t\t\tcallback = path;\n\t\t}\n\n\t\tthis.promises.push({\n\t\t\tcallback: callback ? function(url) {\n\t\t\t\treturn callback(url);\n\t\t\t} : Router.pathMatcher(path),\n\t\t\tscraper: null,\n\t\t\trqMethod: null\n\t\t});\n\t\treturn this.get();\n\t},\n\t/**\n\t * Sets the request method to be a simple HTTP GET.\n\t * {@see AbstractScraper.get}\n\t *\n\t * @return {!Router} This router.\n\t * @public\n\t */\n\tget: function() {\n\t\tvar length = this.promises.length,\n\t\t\tlast = this.promises[length - 1];\n\t\tif (length && last) {\n\t\t\tlast.rqMethod = function(scraper, url) {\n\t\t\t\tscraper.get(url);\n\t\t\t};\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new ScraperError('');\n\t\t}\n\t},\n\t/**\n\t * Sets the request method to be according to the options.\n\t * {@see AbstractScraper.request}\n\t *\n\t * @param  {!Object} options Request options.\n\t * @return {!Router} This router.\n\t * @public\n\t */\n\trequest: function(options) {\n\t\tvar length = this.promises.length,\n\t\t\tlast = this.promises[length - 1];\n\t\tif (length && last) {\n\t\t\tlast.rqMethod = function(scraper, url) {\n\t\t\t\toptions.uri = url;\n\t\t\t\tscraper.request(options);\n\t\t\t};\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new ScraperError('');\n\t\t}\n\t},\n\t/**\n\t * A promise to be triggered when none of the paths where matched.\n\t * This is a one time promise, which means that the last promise\n\t *   is gonna be the one to be executed.\n\t *\n\t * @param  {!function(!string=)} callback Function with the url as\n\t *   a parameter.\n\t * @return {!Router} This router.\n\t * @public\n\t */\n\totherwise: function(callback) {\n\t\tthis.otherwiseFn = callback;\n\t\treturn this;\n\t},\n\t/**\n\t * Creates a static scraper, and associates it with the current\n\t *   router promise chain. Note that this method returns a\n\t *   {@see ScraperPromise} of a {@see StaticScraper}.\n\t *\n\t * @return {!ScraperPromise} A promise for the scraper.\n\t * @public\n\t */\n\tcreateStatic: function() {\n\t\tvar length = this.promises.length,\n\t\t\tlast = this.promises[length - 1];\n\t\tif (length && last && !last.scraper) {\n\t\t\tvar ss = StaticScraper.create();\n\t\t\tlast.scraper = ss;\n\t\t\treturn ss;\n\t\t} else {\n\t\t\tthrow new ScraperError('');\n\t\t}\n\t},\n\t/**\n\t * Associates the current route with the a scraper (promise)\n\t *   instance. Keep in mind that the done promise will not be\n\t *   available.\n\t *\n\t * @param  {!AbstractScraper} scraper A scraper instance to use.\n\t * @return {!Router} This router.\n\t * @public\n\t */\n\tuse: function(scraper) {\n\t\tvar length = this.promises.length,\n\t\t\tlast = this.promises[length - 1];\n\t\tif (length && last && !last.scraper) {\n\t\t\tlast.scraper = scraper;\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new ScraperError('');\n\t\t}\n\t},\n\t/**\n\t * Creates a dynamic scraper, and associates it with the current\n\t *   router promise chain. Note that this method returns a\n\t *   {@see ScraperPromise} of a {@see DynamicScraper}.\n\t *\n\t * @return {!ScraperPromise} A promise for the scraper.\n\t * @public\n\t */\n\tcreateDynamic: function() {\n\t\tvar length = this.promises.length,\n\t\t\tlast = this.promises[length - 1];\n\t\tif (length && last && !last.scraper) {\n\t\t\tvar ss = DynamicScraper.create();\n\t\t\tlast.scraper = ss;\n\t\t\treturn ss;\n\t\t} else {\n\t\t\tthrow new ScraperError('');\n\t\t}\n\t},\n\t/**\n\t * Routes a url through every path that matches it.\n\t *\n\t * @param  {!string} url The url to route.\n\t * @param  {!function(boolean)} callback Function to call when the\n\t *   routing is complete. If any of the paths was found the\n\t *   parameter is true, false otherwise.\n\t * @return {!Router} This router.\n\t * @public\n\t */\n\troute: function(url, callback) {\n\t\tvar that = this,\n\t\t\tatLeastOne = false,\n\t\t\tstopFlag = {},\n\t\t\tlastReturn;\n\t\tcallback = callback || function() {};\n\t\tasync.eachSeries(this.promises, function(promiseObj, done) {\n\n\t\t\tvar matcher = promiseObj.callback,\n\t\t\t\tscraper,\n\t\t\t\treqMethod = promiseObj.rqMethod;\n\t\t\tvar result = matcher(url);\n\t\t\tif (!!result) {\n\t\t\t\tscraper = promiseObj.scraper.clone();\n\t\t\t\tatLeastOne = true;\n\t\t\t\tscraper._setChainParameter(result);\n\t\t\t\tscraper.done(function(lr, utils) {\n\t\t\t\t\tlastReturn = lr;\n\t\t\t\t\tdone(that.firstMatchStop ? stopFlag : undefined);\n\t\t\t\t});\n\t\t\t\treqMethod(scraper, url);\n\t\t\t} else {\n\t\t\t\tdone();\n\t\t\t}\n\n\t\t}, function() {\n\t\t\tif (!atLeastOne) {\n\t\t\t\tthat.otherwiseFn(url);\n\t\t\t}\n\t\t\tcallback(atLeastOne, lastReturn);\n\t\t});\n\t\treturn this;\n\t}\n};\n/**\n * Creates a function to match a path against a string.\n *\n * @param  {!(string|RegExp)} pathOrRE Pattern to match, if it's a\n *   string it will be transformed into a regular expression.\n * @return {!function(string):(Object|booelan)} A matching function,\n *   that given a string will check if it matches the path. If the\n *   path has parameters it will return an object with the parameters\n *   as keys and the values as the values of the parameters. An empty\n *   object if there were no valid parameters or false if the path\n *   doesn't match with the string.\n * @public\n * @static\n */\nRouter.pathMatcher = function(pathOrRE) {\n\tvar pattern,\n\t\tkeys = ['url'];\n\tif (pathOrRE instanceof RegExp) {\n\t\tpattern = pathOrRE;\n\t} else if (typeof pathOrRE === 'string') {\n\t\tpattern = pathToRegExp(pathOrRE, keys);\n\t} else {\n\t\tthrow new ScraperError('A path must be a string or a regular expression.');\n\t}\n\n\treturn function patternMatchingFunction(url) {\n\t\tvar match = pattern.exec(url);\n\t\tif (!match) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn keys.reduce(function(obj, value, index) {\n\t\t\t\tobj[value] = match[index];\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\t\t}\n\t};\n};\n\nmodule.exports = Router;\n","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/Gruntfile.js":"var testServer = require('./test/setupServer');\n\nvar MOCHA_TIMEOUT_S = 10,\n\tMOCHA_TIMEOUT_MS = MOCHA_TIMEOUT_S * 1000,\n\tMOCHA_OPTIONS = {\n\t\treporter: 'spec',\n\t\ttimeout: MOCHA_TIMEOUT_MS\n\t},\n\tCOVERAGE_THRESHOLD = 95;\n\nmodule.exports = function(grunt) {\n\tgrunt.loadNpmTasks('grunt-mocha-test');\n\tgrunt.loadNpmTasks('grunt-contrib-jshint');\n\tgrunt.loadNpmTasks('grunt-contrib-watch');\n\tgrunt.loadNpmTasks('grunt-contrib-clean');\n\tgrunt.loadNpmTasks('grunt-exec');\n\n\tgrunt.initConfig({\n\t\texec: {\n\t\t\tcoverage: {\n\t\t\t\tcommand: 'istanbul cover ./node_modules/mocha/bin/_mocha -x src/PhantomWrapper.js -- -t ' + MOCHA_TIMEOUT_MS + ' --root src/ test/'\n\t\t\t},\n\t\t\tcoveralls: {\n\t\t\t\tcommand: 'istanbul cover ./node_modules/mocha/bin/_mocha -x src/PhantomWrapper.js --report lcovonly -- -t ' + MOCHA_TIMEOUT_MS + ' -x src/PhantomWrapper.js --root src/ test/ && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js'\n\t\t\t},\n\t\t\t'check-coverage': {\n\t\t\t\tcommand: 'istanbul check-coverage --lines ' + COVERAGE_THRESHOLD + ' --statements ' + COVERAGE_THRESHOLD + ' --functions ' + COVERAGE_THRESHOLD + ' --branches ' + COVERAGE_THRESHOLD + ' ./coverage/coverage.json'\n\t\t\t}\n\t\t},\n\t\tclean: {\n\t\t\tcoverage: {\n\t\t\t\tsrc: ['coverage/']\n\t\t\t}\n\t\t},\n\t\twatch: {\n\t\t\tcommon: {\n\t\t\t\tfiles: ['src/**/*.js', 'test/**/*.js', 'Gruntfile.js'],\n\t\t\t\ttasks: ['test']\n\t\t\t}\n\t\t},\n\t\tjshint: {\n\t\t\tall: ['src/**/*.js', 'test/**/*.js']\n\t\t},\n\t\tmochaTest: {\n\t\t\tabstractScraper: {\n\t\t\t\tsrc: 'test/AbstractScraper.js',\n\t\t\t\toptions: MOCHA_OPTIONS\n\t\t\t},\n\t\t\tstaticScraper: {\n\t\t\t\tsrc: 'test/StaticScraper.js',\n\t\t\t\toptions: MOCHA_OPTIONS\n\t\t\t},\n\t\t\tdynamicScraper: {\n\t\t\t\tsrc: 'test/DynamicScraper.js',\n\t\t\t\toptions: MOCHA_OPTIONS\n\t\t\t},\n\t\t\tscraperPromise: {\n\t\t\t\tsrc: 'test/ScraperPromise.js',\n\t\t\t\toptions: MOCHA_OPTIONS\n\t\t\t},\n\t\t\trouter: {\n\t\t\t\tsrc: 'test/Router.js',\n\t\t\t\toptions: MOCHA_OPTIONS\n\t\t\t},\n\t\t\tscraperError: {\n\t\t\t\tsrc: 'test/ScraperError.js',\n\t\t\t\toptions: MOCHA_OPTIONS\n\t\t\t},\n\t\t\tcommandLine: {\n\t\t\t\tsrc: 'test/commandLine.js',\n\t\t\t\toptions: MOCHA_OPTIONS\n\t\t\t},\n\t\t\tall: {\n\t\t\t\tsrc: ['test/AbstractScraper.js', 'test/StaticScraper.js', 'test/DynamicScraper.js', 'test/ScraperPromise.js', 'test/Router.js', 'test/ScraperError.js', 'test/commandLine.js'],\n\t\t\t\toptions: MOCHA_OPTIONS\n\t\t\t}\n\t\t}\n\t});\n\n\tvar server;\n\n\tgrunt.registerTask('serve', 'Starts express testing server', function() {\n\t\tserver = testServer(grunt);\n\t});\n\n\tgrunt.registerTask('unserve', function() {\n\t\tif (server) {\n\t\t\tserver.close();\n\t\t}\n\t});\n\n\tgrunt.registerTask('serve-and-test', ['serve', 'mochaTest:all', 'unserve']);\n\n\tgrunt.registerTask('coverage', ['clean', 'jshint', 'serve', 'exec:coverage', 'exec:check-coverage', 'unserve']);\n\tgrunt.registerTask('coveralls', ['clean', 'jshint', 'serve', 'exec:coveralls', 'exec:check-coverage', 'unserve']);\n\n\tgrunt.registerTask('unit', ['jshint', 'serve-and-test']);\n\tgrunt.registerTask('test', ['coverage']);\n\n\tgrunt.registerTask('watch-all', ['serve', 'watch', 'unserve']);\n};","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/test/setupServer.js":"var express = require('express'),\n\tfs = require('fs');\n\nmodule.exports = function(grunt, port) {\n\tvar app = express(),\n\t\tHN_CLONE = fs.readFileSync(__dirname + '/static/hacker-news-clone.html');\n\n\tapp.get('/hacker-news-clone', function(req, res) {\n\t\tres.status(200);\n\t\tres.send(HN_CLONE);\n\t});\n\n\tapp.post('/hacker-news-clone', function(req, res) {\n\t\tres.status(200);\n\t\tres.send('<html><head></head><body><div id=\"POST_MESSAGE\">random text</div></body></html>');\n\t});\n\n\tapp.param('id', function(req, res, next, id) {\n\t\tvar regex = /^[\\d\\w]+$/;\n\t\tif (regex.test(id)) {\n\t\t\tnext();\n\t\t} else {\n\t\t\tnext('route');\n\t\t}\n\t});\n\tapp.get('/watch/:id', function(req, res, next) {\n\t\tres.status(200);\n\t\tres.send(req.params.id);\n\t});\n\tapp.get('/info/:id', function(req, res, next) {\n\t\tres.status(200);\n\t\tres.send(req.params.id);\n\t});\n\tapp.post('/watch/:id', function(req, res, next) {\n\t\tres.status(200);\n\t\tres.send(req.params.id + \"post\");\n\t});\n\n\tvar server = app.listen(port || 3000, function() {\n\t\tconsole.log('Listening on port %d', server.address().port);\n\t});\n\n\treturn server;\n};","/home/travis/build/npmtest/node-npmtest-scraperjs/node_modules/scraperjs/src/PhantomWrapper_.js":"module.exports = function wrapper(fnStr) {\n  var args = Array.prototype.slice.call(arguments);\n  var rg = /^function\\s+([a-zA-Z_$][a-zA-Z_$0-9]*)?\\((.*?)\\) {/g;\n  var a = rg.exec(fnStr);\n  var fnArgs = a[2].match(/([^,\\s]+)/g) || [];\n  var fnBody = fnStr.slice(fnStr.indexOf(\"{\")+1, fnStr.lastIndexOf(\"}\"));\n  if (!fnArgs[0].match('$')){\n    fnBody = 'var ' + fnArgs[0] + '=$;' + fnBody;\n  }\n  fnArgs.push(fnBody);\n  var scraperFn = Function.apply(this, fnArgs);\n\n  try {\n    var gs = args.slice(1);\n    gs.unshift($);\n    var result = scraperFn.apply(this, gs);\n    return {\n      error: null,\n      result: result\n    };\n  } catch(e) {\n    var errObj = {\n      message: e.message\n    };\n    for(var x in e) {\n      errObj[x] = e[x];\n    }\n    return {\n      error: errObj,\n      result: null\n    };\n  }\n};\n"}